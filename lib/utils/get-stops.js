/** flow stops along a route */

import distance from 'turf-distance'
import point from 'turf-point'
import bearing from 'turf-bearing'

import dbg from 'debug'

/**
 * when autogenerating stops between bona fide stops, how close can an autogenerated stop come to the next non-auto-generated stop, as a fraction
 * of stop spacing?
 */
// TODO make configurable?
const MIN_SPACING_PERCENTAGE = 0.25

const debug = dbg('utils:get-stops')

export default function getStops (segments) {
  if (segments.length === 0) return []

  if (segments.length === 1 && segments[0].geometry.type === 'Point') {
    let coord = segments[0].geometry.coordinates

    return [{
      stopId: segments[0].fromStopId,
      index: 0,
      lat: coord[1],
      lon: coord[0],
      bearing: false, // this will hide directional icon, which is what we want
      autoCreated: !segments[0].stopAtStart,
      distanceFromStart: 0
    }]
  }

  let ret = []

  let coord = segments[0].geometry.coordinates[0]

  ret.push({
    stopId: segments[0].fromStopId,
    index: 0,
    lat: coord[1],
    lon: coord[0],
    bearing: bearing(point(coord), point(segments[0].geometry.coordinates[1])),
    autoCreated: !segments[0].stopAtStart,
    distanceFromStart: 0
  })

  // loop over the route, making stops as we go
  let distanceToLastStop = 0
  let distanceToLineSegmentStart = 0

  for (let segIdx = 0; segIdx < segments.length; segIdx++) {
    const segment = segments[segIdx]
    // now loop over line segments within this segment, accumulating distance as we go
    // a single transit segment can have multiple line segments, because we've used a street router between endpoints
    for (let i = 1; i < segment.geometry.coordinates.length; i++) {
      const c0 = segment.geometry.coordinates[i - 1]
      const c1 = segment.geometry.coordinates[i]
      const distanceThisLineSegment = distance(point(c0), point(c1), 'kilometers') * 1000

      // segment.spacing = 0 means no automatic stop creation in this segment
      while (segment.spacing > 0 && distanceToLastStop + segment.spacing < distanceToLineSegmentStart + distanceThisLineSegment) {
        // how far into the segment do we place the stop
        let frac = (distanceToLastStop + segment.spacing - distanceToLineSegmentStart) / distanceThisLineSegment
        if (frac < 0) frac = 0 // most likely the last segment did not have automatic stop creation

        let pos = [c0[0] + (c1[0] - c0[0]) * frac, c0[1] + (c1[1] - c0[1]) * frac]

        // can't just add segment.spacing because of converting negative fractions to zero above
        // this can happen when the last segment did not have automatic stop creation, or had a larger spacing
        // TODO in the latter case, we probably want to continue to apply the spacing from the last line segment until we create a new stop?
        distanceToLastStop = distanceToLineSegmentStart + frac * distanceThisLineSegment

        ret.push({
          stopId: null,
          index: segIdx,
          lat: pos[1],
          lon: pos[0],
          autoCreated: true,
          bearing: bearing(point(c0), point(c1)),
          distanceFromStart: distanceToLastStop
        })
      }

      distanceToLineSegmentStart += distanceThisLineSegment
    }

    if (segment.stopAtEnd) {
      let endCoord = segment.geometry.coordinates.slice(-1)[0]
      ret.push({
        stopId: segment.toStopId,
        index: segIdx + 1,
        lat: endCoord[1],
        lon: endCoord[0],
        autoCreated: false,
        distanceFromStart: distanceToLineSegmentStart,
        bearing: segIdx < segments.length - 1
          ? bearing(point(segments[segIdx + 1].geometry.coordinates[0]), point(segments[segIdx + 1].geometry.coordinates[1]))
          : false
      })

      // restart the spacing
      distanceToLastStop = distanceToLineSegmentStart // distanceToLineSegmentStart already set to the start of the next line segment
    }
  }

  // filter out autocreated stops that are very close to bona fide stops
  ret = ret.filter((stop, stopIndex, stops) => {
    if (!stop.autoCreated) return true

    let spacingThisSegment = segments[stop.index].spacing

    if (spacingThisSegment === 0) {
      // fail harder?
      debug(`segment ${stop.index} contains auto-created stops but does not have automatic stop creation enabled?`)
      return true
    }

    // last stop
    if (stopIndex === stops.length - 1) return true

    // only need to check if it's too close to the next stop, as it will always be spaced away from the previous
    // stop, since we flow stops forward from the bona fide stops
    let nextStop = stops[stopIndex + 1]
    let delta = nextStop.distanceFromStart - stop.distanceFromStart
    if (!nextStop.autoCreated && delta / spacingThisSegment < MIN_SPACING_PERCENTAGE) return false
    else return true
  })

  return ret
}
