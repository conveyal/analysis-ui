// @flow
import distance from '@turf/distance'
import {point} from '@turf/helpers'

import type {Segment, Stop} from '../types'

const MIN_SPACING_PERCENTAGE = 0.25

/**
 * Flow stops along a route. When autogenerating stops between bona fide stops,
 * how close can an autogenerated stop come to the next non-auto-generated stop,
 * as a fraction of stop spacing? TODO Make configurable?
 */
export default function getStops (segments: Segment[]): Stop[] {
  if (segments.length === 0) return []
  if (segments.length === 1 && segments[0].geometry.type === 'Point') {
    const coord = segments[0].geometry.coordinates
    return [
      {
        stopId: segments[0].fromStopId,
        index: 0,
        lat: coord[1],
        lon: coord[0],
        autoCreated: !segments[0].stopAtStart,
        distanceFromStart: 0
      }
    ]
  }

  const stops = []
  const coord = segments[0].geometry.coordinates[0]
  stops.push({
    stopId: segments[0].fromStopId,
    index: 0,
    lat: coord[1],
    lon: coord[0],
    autoCreated: !segments[0].stopAtStart,
    distanceFromStart: 0
  })

  // loop over the route, making stops as we go
  let distanceToLastStop = 0
  let distanceToLineSegmentStart = 0

  for (let segIdx = 0; segIdx < segments.length; segIdx++) {
    const segment = segments[segIdx]
    // now loop over line segments within this segment, accumulating distance as we go
    // a single transit segment can have multiple line segments, because we've used a street router between endpoints
    for (let i = 1; i < segment.geometry.coordinates.length; i++) {
      const c0 = segment.geometry.coordinates[i - 1]
      const c1 = segment.geometry.coordinates[i]
      const distanceThisLineSegment =
        distance(point(c0), point(c1), 'kilometers') * 1000

      // segment.spacing = 0 means no automatic stop creation in this segment
      while (
        segment.spacing > 0 &&
        distanceToLastStop + segment.spacing <
          distanceToLineSegmentStart + distanceThisLineSegment
      ) {
        // how far into the segment do we place the stop
        let frac =
          (distanceToLastStop + segment.spacing - distanceToLineSegmentStart) /
          distanceThisLineSegment
        if (frac < 0) frac = 0 // most likely the last segment did not have automatic stop creation

        const lon = c0[0] + (c1[0] - c0[0]) * frac
        const lat = c0[1] + (c1[1] - c0[1]) * frac

        // can't just add segment.spacing because of converting negative fractions to zero above
        // this can happen when the last segment did not have automatic stop creation, or had a larger spacing
        // TODO in the latter case, we probably want to continue to apply the spacing from the last line segment until we create a new stop?
        distanceToLastStop =
          distanceToLineSegmentStart + frac * distanceThisLineSegment

        stops.push({
          stopId: undefined,
          index: segIdx,
          lat,
          lon,
          autoCreated: true,
          distanceFromStart: distanceToLastStop
        })
      }

      distanceToLineSegmentStart += distanceThisLineSegment
    }

    if (segment.stopAtEnd) {
      const endCoord = segment.geometry.coordinates.slice(-1)[0]
      stops.push({
        stopId: segment.toStopId,
        index: segIdx + 1,
        lat: endCoord[1],
        lon: endCoord[0],
        autoCreated: false,
        distanceFromStart: distanceToLineSegmentStart
      })

      // restart the spacing
      distanceToLastStop = distanceToLineSegmentStart // distanceToLineSegmentStart already set to the start of the next line segment
    }
  }

  // filter out autocreated stops that are very close to bona fide stops
  return stops.filter((stop, stopIndex, stops) => {
    const nextStop = stops[stopIndex + 1]
    if (!stop.autoCreated || stopIndex === stops.length - 1 || nextStop.autoCreated) {
      return true
    }

    const spacingThisSegment = segments[stop.index].spacing
    if (spacingThisSegment === 0) {
      // fail harder?
      console.error(`segment ${stop.index} contains auto-created stops with a stop spacing of 0. Filtering out stops.`)
      return false
    }

    // only need to check if it's too close to the next stop, as it will always
    // be spaced away from the previous stop, since we flow stops forward from
    // the bona fide stops
    const delta = nextStop.distanceFromStart - stop.distanceFromStart
    const spacedCorrectlyFromNextStop =
      delta / spacingThisSegment >= MIN_SPACING_PERCENTAGE

    return spacedCorrectlyFromNextStop
  })
}
